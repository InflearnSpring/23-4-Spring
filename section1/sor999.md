# [spring] 인프런 김영한 스프링 핵심 원리 1

# **1. 객체** 지향 설계와 스프링

### [1. 스프링의 역사](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

### [2. 스프링이란?](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

### [3.객체 지향 프로그래밍](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

### [4. 스프링과 객체 지향](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

### [5. 좋은 객체 지향 설계의 5원칙(SOLID)](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

### [6. 스프링의 필요성](https://www.notion.so/spring-1-1c1ec87e4eca44969c4e99a8855e0873)

# 1. 스프링의 역사

### 과거의 자바

- EJB(Enterprise Java Beans): 2000년 초 자바 표준 기술
- 장점: 트랜젝션 관리, 분산 기술, 엔티티빈(ORM 가능)
    - ORM: 자바 객체를 DB에 편하게 저장/출력
- 단점: 비쌈, 복잡, 어렵, 느림

### **EJB의 대체**

- spring - EJB 컨테이너 대체, 단순함
- 하이버네이트 - EJB 엔티티빈 기술 , JPA 새로운 표준
- EJB 엔티티빈 → 하이버네이트 → JPA
- 현재
    
    표준 인터페이스:  JPA 
    
    JPA구현체들: 하이버네이트,  EclipseLink …
    

---

# 2. **스프링이란?**

1. DI 컨테이너 기술 
2. 스프링 프레임워크 
3. 스프링 부트, 스프링 프레임워크를 포함한 스프링 생태계

### 왜 스프링을 사용하는가?

- 좋은 객체 지향 언어 어플리케이션 개발을 도와주는 프레임워크기 때문

---

# 3. 객체 지향 프로그래밍

### 객체지향 프로그래밍이란?

: 프로그램을 “객체”들의 모임으로 파악

장점:  프로그램을 유연하게 함, 변경 쉬움(다형성)

### 다형성(Polymorphism)

:세상을 역할(인터페이스)과 구현(객체)으로 분리

클라이언트 변경X, but 서버의 구현 기능을 유연하게 변경O

- 실세계 비유
    - 운전자 - 자동차
        
        운전자(역할)→자동차(역할)← 테슬라, 아반떼(구현):자동차 구현을 바꾸어도 운전자는 계속 탈 수 있음. 운전자(클라이언트)는 자동차의 내부구조 몰라도 됨, 자동차가 바뀌어도 운전자는 계속 탈 수 있다.
        
    - 공연 무대
        
        줄리엣 역(역할) - 김태희, 송혜교(구현)
        
- 선 역할(인터페이스) → 후 구현

-장점

- 클라이언트는 역할(인터페이스)만 알면 됨 = 구현 대상의 내부구조 모름, 변경해도 됨, 구현 대상 자체를 변경해도 됨

-객체의 협력 관계

- 혼자 있는 객체는 없음. 클라이언트:요청자, 서버:응답자
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

-자바 언어의 다형성 

- 오버라이딩
- 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경

-한계

- 역할(인터페이스) 변경 → 클라이언트, 서버 모두 변경 필요
    
    인터페이스를 안정적으로 잘 설계하자!
    

---

# 4. 스프링과 객체 지향

:다형성을 활용하여 역할, 구현을 편리하게 다룰 수 있게 지원

-스프링의 제어의 역전(IoC), 의존관계 주입(DI)

---

# 5. 좋은 객체 지향 설계의 5원칙(SOLID)

### SOLID

- SRP: 단일 책임 원칙(single responsibility principle)
    
    :한 클래스는 하나의 책임만
    
    - 책임의 범위 조절
    - 기준 = ‘변경’ ; 변경의 파급 효과를 최소화
- OCP: 개방-폐쇄 원칙 (Open/closed principle)
    
    :소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 함(= 코드의 변경 없이 확장)
    
    - HOW? 다형성 이용 ex) 인터페이스를 구현하는 새 클래스 만듦
    - 스프링의 필요성: java 다형성 활용 → 구현 객체를 변경하기 위해 클라이언트 코드 변경 필요 → OCP 원칙 깨짐 → 객체생성, 연관시켜주는 별도의 조립, 설정자 필요 = 스프링 컨테이너의 역할
- LSP: 리스코프 치환 원칙 (Liskov substitution principle)
    
    :프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 함
    
    - 다형성에서 하위 클래스는인터페이스 규약을 다 지켜야 함
    - EX) 자동차 인터페이스 엑셀 = 앞으로 가라는 규약(반드시 지켜야)
- ISP: 인터페이스 분리 원칙 (Interface segregation principle)
    
    :특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
    
    - 인터페이스의 분리: EX) 자동차(사용자) → 운전(운전자), 정비(정비사)
    - 인터페이스 명확화, 대체 가능성 상승
- DIP: 의존관계 역전 원칙 (Dependency inversion principle)
    
    :프로그래머는 추상화에 의존해야지, 구체화에 의존해선 안된다.
    
    - ‘구현’말고 ‘역할’에 의존: 구현 클래스 의존X, 인터페이스 의존O
    - WHY? 구현에 의존한다면 변경이 어렵다
    - 스프링의 필요성: java 다형성 활용  → 클라이언트가 구현 클래스를 직접 선택 → 추상화, 구체화 모두에 의존→ DIP 위반
    
    ```java
    MemberRepository m = new MemoryMemberRepository();
    //MemberRepository 클라이언트가 구현 클래스 직접 선택
    ```
    

---

# 6. 객체 지향 설계와 스프링

### 스프링의 필요성

:자바의 한계, 좋은 객체 지향 설계를 위한 발판

- JAVA 다형성의 한계: **구현 객체** 변경 → **클라이언트 코드**도 변경. 즉, OCP, DIP를 못지킴
- 스프링 DI 컨테이너: 다형성 + OCP, DIP 원칙
    - DI(Dependency Injection): 의존관계, 의존성 주입

### 좋은 객체 지향 설계

- 인터페이스 → 구현 : 유연 변경 범위 작다, 유연
- 인터페이스 남발: 추상화 비용 증가(바로 구현 클래스를 볼 수 없음)
- 결론
    - if 기능 확장 가능성X → 구체 클래스 직접 사용 & 필요시 리팩터링, 인터페이스 도입
    - else → 처음부터 인터페이스 도입